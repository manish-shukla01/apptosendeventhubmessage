// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import { __awaiter } from "tslib";
import { translate } from "./errors";
import { delay, isNode } from "./util/utils";
import * as log from "./log";
import { defaultRetryAttempts, defaultDelayBetweenRetriesInSeconds } from "./util/constants";
import { resolve } from "dns";
/**
 * Determines whether the object is a Delivery object.
 * @ignore
 */
function isDelivery(obj) {
    let result = false;
    if (obj &&
        typeof obj.id === "number" &&
        typeof obj.settled === "boolean" &&
        typeof obj.remote_settled === "boolean" &&
        typeof obj.format === "number") {
        result = true;
    }
    return result;
}
/**
 * Describes the retry operation type.
 * @enum RetryOperationType
 */
export var RetryOperationType;
(function (RetryOperationType) {
    RetryOperationType["cbsAuth"] = "cbsAuth";
    RetryOperationType["connection"] = "connection";
    RetryOperationType["management"] = "management";
    RetryOperationType["receiverLink"] = "receiverLink";
    RetryOperationType["senderLink"] = "senderLink";
    RetryOperationType["sendMessage"] = "sendMessage";
    RetryOperationType["session"] = "session";
})(RetryOperationType || (RetryOperationType = {}));
/**
 * Validates the retry config.
 * @ignore
 */
function validateRetryConfig(config) {
    if (!config.operation) {
        throw new TypeError("Missing 'operation' in retry configuration");
    }
    if (!config.connectionId) {
        throw new TypeError("Missing 'connectionId' in retry configuration");
    }
    if (!config.operationType) {
        throw new TypeError("Missing 'operationType' in retry configuration");
    }
}
function checkNetworkConnection(host) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isNode) {
            return new Promise((res) => {
                log.retry("Calling dns.resolve to determine network connection status.");
                resolve(host, function (err) {
                    if (err) {
                        log.retry("Error thrown from dns.resolve in network connection check: '%s', %O", err.code || err.name, err);
                        // List of possible DNS error codes: https://nodejs.org/dist/latest-v12.x/docs/api/dns.html#dns_error_codes
                        // Only when dns.resolve returns an error we expect to see when the network is down, resolve as 'false'.
                        if (err.code === "ECONNREFUSED" || err.code === "ETIMEOUT") {
                            return res(false);
                        }
                    }
                    else {
                        log.retry("Successfully resolved host via dns.resolve in network connection check");
                    }
                    return res(true);
                });
            });
        }
        else {
            return window.navigator.onLine;
        }
    });
}
/**
 * It will attempt to linearly retry an operation specified number of times with a specified
 * delay in between each retry. The retries will only happen if the error is retryable.
 *
 * @param {RetryConfig<T>} config Parameters to configure retry operation.
 *
 * @return {Promise<T>} Promise<T>.
 */
export function retry(config) {
    return __awaiter(this, void 0, void 0, function* () {
        validateRetryConfig(config);
        if (config.times == undefined)
            config.times = defaultRetryAttempts;
        if (config.delayInSeconds == undefined) {
            config.delayInSeconds = defaultDelayBetweenRetriesInSeconds;
        }
        let lastError;
        let result;
        let success = false;
        for (let i = 0; i < config.times; i++) {
            const j = i + 1;
            log.retry("[%s] Retry for '%s', attempt number: %d", config.connectionId, config.operationType, j);
            try {
                result = yield config.operation();
                success = true;
                log.retry("[%s] Success for '%s', after attempt number: %d.", config.connectionId, config.operationType, j);
                if (result && !isDelivery(result)) {
                    log.retry("[%s] Success result for '%s': %O", config.connectionId, config.operationType, result);
                }
                break;
            }
            catch (err) {
                if (!err.translated) {
                    err = translate(err);
                }
                if (!err.retryable && err.name === "ServiceCommunicationError" && config.connectionHost) {
                    const isConnected = yield checkNetworkConnection(config.connectionHost);
                    if (!isConnected) {
                        err.name = "ConnectionLostError";
                        err.retryable = true;
                    }
                }
                lastError = err;
                log.error("[%s] Error occured for '%s' in attempt number %d: %O", config.connectionId, config.operationType, j, err);
                if (lastError && lastError.retryable) {
                    log.error("[%s] Sleeping for %d seconds for '%s'.", config.connectionId, config.delayInSeconds, config.operationType);
                    yield delay(config.delayInSeconds * 1000);
                    continue;
                }
                else {
                    break;
                }
            }
        }
        if (success) {
            return result;
        }
        else {
            throw lastError;
        }
    });
}
//# sourceMappingURL=retry.js.map